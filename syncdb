#!/bin/bash -u

# ***********************************************
#
# syncDB v0.2.4
# by JP Lew (jplew.com)
#
# ***********************************************

# ===================================================
#  SITE-SPECIFIC VARIABLES (mandatory for each site)
# ===================================================

r_user=myusername
r_host=ftp.mywebsite.com
r_web_dir=public_html
r_port= # usually left blank

r_web_addr=mywebsite.com
l_web_addr=dev.mywebsite.com

    # $r_user is your FTP username. It is used to ssh into your site: `ssh
    # $r_user@ftp.mywebsite.com`.

    # $r_host is your FTP hostname. It is used to ssh into your site: `ssh
    # myusername@$r_host`.

    # $r_web_dir is the directory in which your remote site is located (relative to
    # the user root). It's usually public_html, www, www/mywebsite.com/public_html
    # etc...).

    # $r_port is an optional field specifying the port number to use. In most cases
    # this can remain blank, although Host Gator for example requires port 22 to
    # connect via SSH.

    # $r_web_addr is the web address, or site URL of your site. It is used to
    # search and replace your database.

    # $l_web_addr is whatever you set your local server name to. Something like
    # localhost:8888/mywebsite or dev.mywebsite.com or mywebsite.dev. We'll be
    # search and replacing this string later on.

l_upload_dir=wp-content/uploads/
r_upload_dir=wp-content/uploads/

    # $l_upload_dir and $r_upload_dir is where your site's 'uploads' folder is
    # located. This tells rsync which directories on your FTP should be
    # synchronized. If you're using WP-Skeleton
    # <http://markjaquith.wordpress.com/2012/05/26/wordpress-skeleton/>, all you
    # have to synchronize is your shared/ folder (content/uploads/ is symlinked to
    # shared/content/uploads/). Otherwise, it's probably wp-content/uploads/.
    # Remember to add a trailing slash.

no_drop= # set to true if your host sucks

    # ---------------------------------------------------------
    # `drop database` work-around
    # Some servers forbid the `drop database` command (Arvixe, I'm looking at you.)
    # Fortunately, there is an alternate mysql command we can issue to drop all the
    # tables in a database. By setting $no_drop to "true", the script will invoke
    # that command instead of the standard `drop`. Leave blank for default
    # behavior.
    # ---------------------------------------------------------


# ==========================================================
#  SYSTEM-WIDE VARIABLES (preferences set once per machine)
# ==========================================================

#l_mysql=
#l_mysqldump=
l_mysql=/Applications/MAMP/Library/bin/mysql
l_mysqldump=/Applications/MAMP/Library/bin/mysqldump

    # ---------------------------------------------------------
    # Custom mysql binaries (local)
    # If you're using MAMP, you need to specify which mysql and mysqldump binaries
    # you want to invoke: MAMP's. This is because, by default, running mysql or
    # mysqldump from the command line will execute your system defaults (type
    # `which mysql` to see where they're located). 
    #
    # If you run your own AMP stack, then leave these variables blank.
    # ---------------------------------------------------------

# ========================================
#  OPTIONAL VARIABLES (you almost certainly won't have to touch these)
# ========================================

# This is the arbitrary name and path to your backups folder. Located in your site's root directory. 
l_bak_dir=.bak
r_bak_dir=.bak

# Arbitrary name for the dump files which will be transferred across servers.
l_bak_name2=latest-local.mssql 
r_bak_name2=latest-remote.mssql

# $l_site_dir is the absolute path to your local site. This is automatically
# deduced based on the directory into which you moved SyncDB.
l_site_dir=${PWD}
# $l_web_dir is the name of your site's root directory (same as $l_site_dir,
# but with the preceding directory path stripped off).
l_web_dir=${PWD##*/}

# Path expansions. You likely leave these as-is.
l_bak_path2=$l_site_dir/$l_bak_dir/$l_bak_name2
l_upload_path=$l_site_dir/$l_upload_dir
r_upload_path=$r_web_dir/$r_upload_dir
r_site_dir=$HOME/$r_web_dir

# The --port flag has to be uppercase for `scp`, lowercase for `ssh`. sigh. 
ssh_port_define="-p $r_port "
scp_port_define="-P $r_port "

ssh_port=${r_port:+$ssh_port_define}
scp_port=${r_port:+$scp_port_define}

# ========================================
#  GLOBAL CONSTANTS (no need to customize)
# ========================================

# pretty colours
if [ "$TERM" != "dumb" ]; then
    red=$(tput setaf 1 || tput AF 1)
    green=$(tput setaf 2 || tput AF 2)
    yellow=$(tput setaf 3 || tput AF 3)
    blue=$(tput setaf 4 || tput AF 4)
    magenta=$(tput setaf 5 || tput AF 5)
    cyan=$(tput setaf 6 || tput AF 6)
    reset=$(tput sgr0)
    bold=$(tput bold)
else
    red=
    green=
    yellow=
    blue=
    magenta=
    cyan=
    reset=
    bold=
fi

msgSuccess='Success:'
msgError='Error:'
    
# Date placeholders (for naming the SQL dump files)
today=$(date +"%y%m%d")
now=$(date +"%y%m%d-%H%M")

# Search-Replace-DB
searchScriptName=srdb.class.php
cliScriptName=srdb.cli.php
srdbPath=https://raw.github.com/interconnectit/Search-Replace-DB/master/
searchScriptPath=$srdbPath$searchScriptName
cliScriptPath=$srdbPath$cliScriptName

# initialize variable. Used because we need to test the SSH connection only once.
checked=

# ====================================
#  FUNCTIONS
# ====================================

# ---------------------------------------------------------
# help ()
# Print list of valid SyncDB commands.
# ---------------------------------------------------------
help () {

cat <<EOF
    ${blue}SyncDB List of Commands$reset

    • backup_local_db
    • do_login_backup
    • do_remote_operations
    • do_search_replace_remote
    • download_remote_db
    • push
    • pull
    • replace_local_db
    • rsync_pull
    • rsync_push
    • search_replace_local
    • test_ssh
    • upload_local_db
    • upload_script

EOF

    exit 0
}

# ---------------------------------------------------------
# test_ssh ()
# Check if the SSH connection is working.
# ---------------------------------------------------------
test_ssh () {
    echo "${blue}Checking if SSH connection is working...$reset"
    echo
    echo "ssh -q $ssh_port$r_user@$r_host exit"

    ssh -q $ssh_port$r_user@$r_host exit

    if [ $? == 0 ] # check if the SSH connection is working
    then
        echo
        echo "${green}${msgSuccess}$reset SSH connection is working."
        echo
    else
        echo "$red$msgError$reset could not connect to host. Confirm that the SSH connection, $yellow$r_user$reset@$yellow$r_host$reset, is working."
        exit 1
    fi
}


# ---------------------------------------------------------
# get_local_db_details ()
# Extract the local database details from wp-config.php
# ---------------------------------------------------------
get_local_db_details () {

    echo 
    echo "${blue}Fetching local database login details...$reset"

    # Change directory to site root (where local-config.php and wp-config.php are located)
    if [ ! -d $l_site_dir ] ; then
        echo "${red}$msgError$reset: Directory $l_site_dir does not exist"
        echo
        exit
    else
        cd $l_site_dir
    fi 

    # If local-config.php is not found (if you're using the default Wordpress
    # architecture rather than using WP-Skeleton like I recommend, then search
    # for the local DB info in wp-config.php
    if [[ -f local-config.php ]]
    then
        local_config_file=local-config.php
    elif [[ -f wp-config.php ]]
    then
        local_config_file=wp-config.php
    else
        echo "${red}$msgError$reset: Could not locate local-config.php or wp-config.php"
        exit 1
    fi

    #This tells us how many times DB_USER has been set in the config file.
    number_of_environments=$(grep -c "'DB_USER', '[^']*'.*" $local_config_file)

    #grep returns "filename.php:4" if there's 4 hits. We want to strip away
    #everything up to the colon and just save the number
    number_of_environments=$(echo $number_of_environments | sed -e 's/.*://')
    echo

    #This detects if there's anything weird going on in the config file. If there
    #are more than one instances of DB_USER, that's weird.
    if [[ $number_of_environments < 2 ]]
    then
        return_local_standard
    else
        return_nonstandard local
    fi

    #Local paths
    l_bak_name1=$now-$l_db_name.mssql
    l_bak_path1=$l_site_dir/$l_bak_dir/$l_bak_name1

}

# ---------------------------------------------------------
# return_nonstandard ()
# Some wp-config files have multiple sets of configuration variables, one
# for each environment (local, dev, production/live etc...). 
# This function collects all the login info it can find, organizes it into
# sets, auto-detects which one is the local set, and if necessary asks the user
# which remote server they want to sync with. 
# This function accepts a parameter, either 'local' or 'remote'. 
# ---------------------------------------------------------
return_nonstandard () {

    echo "SyncDB has detected multiple remote environment configurations in your config file."

    #read the argument passed to the function. If the argument was omitted,
    #default to local
    parameter=${1:-local}

    if [[ -f local-config.php ]]
    then
        local_config_file=local-config.php
    elif [[ -f wp-config.php ]]
    then
        local_config_file=wp-config.php
    else
        echo "${red}$msgError$reset: Could not locate local-config.php or wp-config.php"
        exit 1
    fi

    #grep the config file for all relevants hits, and saves them to their
    #respective category. All hits are delimited by spaces.
    l_db_name=$(sed -n "s/.*DB_NAME', '\([^']*\)'.*/\1/p" $local_config_file)
    l_db_user=$(sed -n "s/.*DB_USER', '\([^']*\)'.*/\1/p" $local_config_file)
    l_db_pass=$(sed -n "s/.*DB_PASSWORD', '\([^']*\)'.*/\1/p" $local_config_file)
    l_db_host=$(sed -n "s/.*DB_HOST', '\([^']*\)'.*/\1/p" $local_config_file)

    #This splits the previous values into arrays
    name_array=(${l_db_name// / })
    user_array=(${l_db_user// / })
    pass_array=(${l_db_pass// / })
    host_array=(${l_db_host// / })

    #Checking if DB_HOST was empty for any environments. This means it
    #wasn't hard-coded, and is using _ENV{DATABASE-SERVER} instead. Rather than
    #leave it blank, we want to assign it the value "unset"
    for (( i = 0 ; i < $number_of_environments ; i++ )) 
    do

        #when -u is set for bash, one valid way to test the existence of a
        #variable, without getting an "unbound variable" error, is to set the
        #default value to empty like this ${variable-}
        if [ -z "${host_array[$i]-}" ]
        then
            db_host=${DATABASE_SERVER:=unset}

            if [[ $db_host ]] 
            then
                host_array[$i]=$db_host
            fi
        fi

    done

    #env_array will be the final list of remote environments
    declare -a env_array=()

    #for each environment detected, let's test if it's local by checking if
    #anything is set to "root". We're assuming no-one's using "root" as their remote
    #login or password.
    for (( i = 0 ; i < $number_of_environments ; i++ )) 
    do

        #add the current environment to the array
        env_array[$i]=$i

        #this will create array set_0, set_1, set_2 etc... which will reorganize all the grepped values into their respective environment
        eval "declare -a "set_${i}"=( ${name_array[$i]} ${user_array[$i]} ${pass_array[$i]} ${host_array[$i]} )"

        #because we're using arrays we have to use some indirect referencing trickery to iterate properly
        _set="set_$i"[@]
        set=( "${!_set}" )

        #k is a separate counter to iterate through the four environment variables
        k=0
        for j in "${set[@]}"
        do
            #out of all the environments, let's set the default to 0
            local_env=0
            if [ $j == "root" ] 
            then
                #hopefully only one of the environments is using root as a login
                local_env=$i
            fi

            #remove the local environment from the final array, so the user doesn't
            #have to consider it.
            unset env_array[$local_env]

            if [ "$i" -ne "$local_env" ]
            then

                #Display the title, "Environment #x", only once, on the first
                #pass through the current environment's config values
                [[ $k == 0 ]] && echo "    ENVIRONMENT #$i" 
                header=
                case $k in
                    0 )
                        header="DB_NAME" ;;
                    1 )
                        header="DB_USER" ;;
                    2 )
                        header="DB_PASS" ;;
                    3 )
                        header="DB_HOST" ;;
                esac
                echo "    $header:      $j"

                ((k++))
            fi

        done
        echo

    done

    #Now that we've figured out which environment is the local one, let's set all
    #the variables to use for the local mysql operations
    local_env_ref_0=set_$local_env[0]
    local_env_ref_1=set_$local_env[1]
    local_env_ref_2=set_$local_env[2]
    local_env_ref_3=set_$local_env[3]

    l_db_name=${!local_env_ref_0}
    l_db_user=${!local_env_ref_1}
    l_db_pass=${!local_env_ref_2}
    l_db_host=${!local_env_ref_3}

    #echo "============================================================" 
    #echo " LOCAL DATABASE DETAILS" 
    #echo "============================================================" 
    #echo

    #echo "local DB_NAME is:       $l_db_name"
    #echo "local DB_USER is:       $l_db_user"
    #echo "local DB_PASSWORD is:   $l_db_pass"
    #echo "local DB_HOST is:       $l_db_host"
    #echo

    #Only prompt the user to pick the remote server if this function has been
    #passed with the "remote" parameter set
    if [ $parameter == "remote" ]
    then

        #Now that we've narrowed down the possibilities of what might be a remote
        #server, prompt the user to pick which one to synchronize
        echo "Synchronize with which remote server?"
        select m in "${env_array[@]}"
        do

            echo
            echo "You chose Environment #$m as your remote server."
            echo

            remote_env=$m

            #SyncDB will only use one set of remote environment variables, so set them
            #here based on the user's choice
            remote_env_ref_0=set_$remote_env[0]
            remote_env_ref_1=set_$remote_env[1]
            remote_env_ref_2=set_$remote_env[2]
            remote_env_ref_3=set_$remote_env[3]

            r_db_name=${!remote_env_ref_0}
            r_db_user=${!remote_env_ref_1}
            r_db_pass=${!remote_env_ref_2}
            r_db_host=${!remote_env_ref_3:-$PHP_OUT}

            echo "============================================================" 
            echo " REMOTE DATABASE DETAILS" 
            echo "============================================================" 
            echo

            echo "remote DB_NAME is:       $r_db_name"
            echo "remote DB_USER is:       $r_db_user"
            echo "remote DB_PASSWORD is:   $r_db_pass"
            echo "remote DB_HOST is:       $r_db_host"

            echo
            break

        done

    fi
    echo
}

# ---------------------------------------------------------
# return_local_standard ()
# A standard wp-config file has one set of environment variables declared. A
# non-standard has more than one. This function fetches the local database
# login details from a normal config file.
# ---------------------------------------------------------
return_local_standard () {

    #grep the config file for the MySQL login details
    l_db_name=$(sed -n "s/.*DB_NAME', '\([^']*\)'.*/\1/p" $local_config_file)
    l_db_user=$(sed -n "s/.*DB_USER', '\([^']*\)'.*/\1/p" $local_config_file)
    l_db_pass=$(sed -n "s/.*DB_PASSWORD', '\([^']*\)'.*/\1/p" $local_config_file)
    l_db_host=$(sed -n "s/.*DB_HOST', '\([^']*\)'.*/\1/p" $local_config_file)
}

# ---------------------------------------------------------
# return_remote_standard ()
# Get the remote database login details. Used if the config file has only one
# environment specified.
# ---------------------------------------------------------
return_remote_standard () {

    #grep the config file for the MySQL login details
    r_db_name=$(sed -n "s/.*DB_NAME', '\([^']*\)'.*/\1/p" wp-config.php)
    r_db_user=$(sed -n "s/.*DB_USER', '\([^']*\)'.*/\1/p" wp-config.php)
    r_db_pass=$(sed -n "s/.*DB_PASSWORD', '\([^']*\)'.*/\1/p" wp-config.php)
    r_db_host=$(sed -n "s/.*DB_HOST', '\([^']*\)'.*/\1/p" wp-config.php)

}

# ---------------------------------------------------------
# get_remote_db_details ()
# Extract the remote database details from wp-config.php
# ---------------------------------------------------------
get_remote_db_details () {

    echo "${blue}Fetching remote database login details...$reset"

    # Change directory to site root (where local-config.php and wp-config.php are located)
    if [ ! -d $r_site_dir ] ; then
        echo "${red}$msgError$reset: Directory $r_site_dir does not exist"
        echo
        exit 1
    else
        cd $r_site_dir
    fi 
    
    if [[ ! -f wp-config.php ]]
    then
        echo "${red}$msgError$reset: Could not locate wp-config.php"
        exit 1
    fi

    #This tells us how many times DB_USER has been set in the config file.
    number_of_environments=$(grep -c "'DB_USER', '[^']*'.*" wp-config.php)

    #grep returns "filename.php:4" if there's 4 hits. We want to strip away
    #everything up to the colon and just save the number
    number_of_environments=$(echo $number_of_environments | sed -e 's/.*://')
    echo

    #This detects if there's anything weird going on in the config file. If there
    #are more than one instances of DB_USER, that's weird.
    if [[ $number_of_environments < 2 ]]
    then
        return_remote_standard
    else
        return_nonstandard remote
    fi

    #Local paths
    r_bak_name1=$now-$r_db_name.mssql 

}

# ---------------------------------------------------------
# backup_remote_db ()
# Dump the remote database and back it up
# ---------------------------------------------------------
backup_remote_db () {

    get_remote_db_details

    echo "${blue}Backing up remote database...$reset"

    cd $HOME/$r_web_dir

    if [ ! -d $r_bak_dir ]
    then
        mkdir $r_bak_dir 
    fi

    cd $r_bak_dir

    echo "mysqldump -u$r_db_user -p$r_db_pass -h $r_db_host $r_db_name | bzip2 -c > ${r_bak_name1}.bz2"

    mysqldump -u$r_db_user -p$r_db_pass -h $r_db_host $r_db_name | bzip2 -c > ${r_bak_name1}.bz2

    if [[ $? -eq 1 ]]
    then 
        echo ${red}$msgError$reset Could not backup remote database.$reset
        exit 1
    else
        echo
        echo "${green}$msgSuccess$reset Remote database dumped to: $(pwd)/${r_bak_name1}.bz2 and $(pwd)/${r_bak_name2}.bz2"
        echo
    fi

    echo "cp ${r_bak_name1}.bz2 ${r_bak_name2}.bz2"
    cp ${r_bak_name1}.bz2 ${r_bak_name2}.bz2

}


# ---------------------------------------------------------
# download_remote_db ()
# Download the most recent remote database dump file via scp
# ---------------------------------------------------------
download_remote_db () {

    echo "${blue}Downloading remote database...$reset"
    echo

    if [ ! -d $l_bak_dir ] ; then
        mkdir $l_bak_dir 
    fi 

    cd $l_bak_dir

    echo "scp $scp_port$r_user@$r_host:~/$r_web_dir/$r_bak_dir/${r_bak_name2}.bz2 ."

    set -o pipefail

    scp "$scp_port"$r_user@$r_host:~/$r_web_dir/$r_bak_dir/${r_bak_name2}.bz2 .

    if [ $? == 0 -a -f ${r_bak_name2}.bz2 ]; then
        echo
        echo "$green$msgSuccess$reset Remote database downloaded to: $(pwd)/${r_bak_name2}.bz2"
    else
        echo "$red$msgError$reset Download did not work. Could not find $(pwd)/${r_bak_name2}.bz2"
        exit 1
    fi
}

# ---------------------------------------------------------
# backup_local_db ()
# Back up the local database.
# ---------------------------------------------------------
backup_local_db () {

    get_local_db_details

    echo "${blue}Backing up the local database...$reset" 

    cd $l_site_dir

    if [ ! -d $l_bak_dir ]
    then
        mkdir $l_bak_dir; 
    fi

    cd $l_bak_dir

    echo "${l_mysqldump:-mysqldump} -u$l_db_user -p$l_db_pass -h $l_db_host $l_db_name | bzip2 -c > ${l_bak_name1}.bz2"
    echo

    set -o pipefail

    "${l_mysqldump:-mysqldump}" "-u$l_db_user" "-p$l_db_pass" -h "$l_db_host" "$l_db_name" | bzip2 -c > "${l_bak_name1}.bz2"

    if [[ $? -eq 0 ]]
    then
        echo
        echo "$green$msgSuccess$reset Local database backed up to: $(pwd)/${l_bak_name1}.bz2"
    else
        echo
        echo "$red$msgError$reset Database was not backed up. There is a problem with your local MySQL details. Exiting."
        echo
        exit 1
    fi

    echo
    echo "cp ${l_bak_name1}.bz2 ${l_bak_name2}.bz2"
    cp ${l_bak_name1}.bz2 ${l_bak_name2}.bz2
}

# ---------------------------------------------------------
# replace_local_db ()
# Drop and recreate the local database.
# ---------------------------------------------------------
replace_local_db () {

    echo "${blue}Dropping local database...$reset" 

    echo
    get_local_db_details

    echo

    "${l_mysql:-mysql}" "-u$l_db_user" "-p$l_db_pass" -h "$l_db_host" --show-warnings >/dev/null 2>&1<<EOF
        show databases;
        create database if not exists $l_db_name;
        drop database $l_db_name;
        create database $l_db_name;
EOF

    mysql_check_local

    echo
    echo
    echo "${blue}Replacing contents of local database...$reset"
    echo

    cd $l_site_dir/$l_bak_dir

    set -o pipefail

    if [ -f "${r_bak_name2}.bz2" ] 
    then
        bunzip2 < "${r_bak_name2}.bz2" | "${l_mysql:-mysql}" "-u$l_db_user" "-p$l_db_pass" -h "$l_db_host" "$l_db_name" --show-warnings

        if [[ $? -eq 0 ]]
        then
            echo "$green$msgSuccess$reset Local database replaced with contents from remote database."
        else
            echo
            echo "$red$msgError$reset There was an error replacing the contents of the local database."
            echo
            exit 1
        fi

    else
        echo "$red$msgError$reset Remote backup file, "${r_bak_name2}".bz2, does not exist in $(PWD)"
        exit 1
    fi

    echo 

}

# ---------------------------------------------------------
# do_check_for_dirs ()
# Login and verify that the remote paths are set correctly
# ---------------------------------------------------------
do_check_for_dirs () {

    echo "Checking for existence of remote directories..."

    ssh -q ${ssh_port}"$r_user"@"$r_host" "if [[ ! -d "$r_web_dir" ]]; then echo "Remote directory does not exist: $r_web_dir"; exit 1; fi; cd "$r_web_dir"; if [[ ! -d "$r_bak_dir" ]]; then mkdir "$r_bak_dir"; fi;" 

    checked=true
}

# ---------------------------------------------------------
# upload_script ()
# Upload a copy of sync script to FTP
# ---------------------------------------------------------
upload_script () {

    echo "${blue}Uploading sync script...$reset"
    echo

    cd "$l_site_dir"

    # check if we've already checked the remote path structure. If not, check now
    [[ "$checked" ]] || do_check_for_dirs

    # Compare the local version of SyncDB with the remote version. If there's a difference, upload and write over the remote one.
    difference=$(ssh $ssh_port$r_user@$r_host cat $r_web_dir/$r_bak_dir/$(basename $0) 2>/dev/null | diff ./$(basename $0) - )

    echo
    if [[ "$difference" ]]
    then
        echo "scp $scp_port./$(basename $0) $r_user@$r_host:~/$r_web_dir/"
        echo
        scp ${scp_port}./$(basename $0) $r_user@$r_host:~/$r_web_dir/
        echo
        echo "$green$msgSuccess$reset SyncDB script uploaded to: $r_web_dir/$(basename $0) (your local version was more recent)."
    else
        echo "SyncDB script already exists on remote server."
    fi

    echo
    echo

}


# ---------------------------------------------------------
# do_login_backup ()
# Login to the remote server via SSH and call backup_remote_db(). Meant to be
# run locally.
# ---------------------------------------------------------
do_login_backup () {

    [[ "$checked" ]] || do_check_for_dirs

    echo "ssh -t $ssh_port$r_user@$r_host cd $r_web_dir; chmod +x $(basename $0); ./$(basename $0) backup_remote_db;"
    ssh -t $ssh_port$r_user@$r_host "cd $r_web_dir; if [ ! -f .bashrc -a -f /etc/profile ]; then . /etc/profile; fi; ./$(basename $0) backup_remote_db;"

}

# ---------------------------------------------------------
# upload_local_db ()
# Upload local scripts and database backup file to the remote server
# ---------------------------------------------------------
upload_local_db () {

    echo "${blue}Uploading dump file to remote server...$reset"
    echo

    # check if we've already checked the remote path structure. If not, check now
    [[ "$checked" ]] || do_check_for_dirs

    cd $l_site_dir/$l_bak_dir

    if [[ -f "${l_bak_path2}.bz2" ]]
    then
        echo "scp $scp_port${l_bak_path2}.bz2 $r_user@$r_host:~/$r_web_dir/$r_bak_dir"
        scp ${scp_port}${l_bak_path2}.bz2 $r_user@$r_host:~/$r_web_dir/$r_bak_dir
    else
        echo "$red$msgError$reset Could not locate the local dump file at $(pwd)/${l_bak_name2}.bz2."
        echo
        exit 1
    fi

    echo

    #test whether the file was actually uploaded or not
    echo "if ssh $ssh_port$r_user@$r_host test -e $r_web_dir/$r_bak_dir/${l_bak_name2}.bz2" 
    if ssh ${ssh_port}"$r_user"@"$r_host" test -e "$r_web_dir"/"$r_bak_dir"/${l_bak_name2}.bz2 
    then
        echo
        echo "$green$msgSuccess$reset Dump file uploaded to: $r_web_dir/$r_bak_dir/${l_bak_name2}.bz2"
    else
        echo
        echo "$red$msgError$reset Upload failed. The file "$r_web_dir"/"$r_bak_dir"/"${l_bak_name2}".bz2 could not be found on the remote server."
        exit 1
    fi
    echo


}

# ---------------------------------------------------------
# mysql_check_local ()
# Check if the local database is empty.
# ---------------------------------------------------------
mysql_check_local () {

    echo "${blue}Checking if the local database was really emptied...$reset"

    get_local_db_details

    db_exists=$("${l_mysql:-mysql}" -s "-u$l_db_user" "-p$l_db_pass" -h "$l_db_host" --batch --skip-column-names -e "SHOW DATABASES LIKE '$l_db_name'" | grep $l_db_name)

    if [[ ! "$db_exists" ]]
    then
        echo
        echo "${red}$msgError${reset} "${l_mysql:-mysql}" could not connect to database $l_db_name. Check that your login details are set correctly and that the database exists. Exiting."
        exit 1;
    fi

    rows=$("${l_mysql:-mysql}" "-u$l_db_user" "-p$l_db_pass" -h "$l_db_host" --show-warnings -Bse "select count(distinct \`table_name\`) from \`information_schema\`.\`columns\` where \`table_schema\` = '$l_db_name'")

    if [ "$rows" == "0" ]; then
        echo "$green$msgSuccess$reset The database $l_db_name is empty, it has $rows rows."
    else
        echo "$red$msgError$reset Database $l_db_name is not empty, it still has $rows rows."
        exit 1
    fi
}

# ---------------------------------------------------------
# mysql_check_remote ()
# Check if the remote database is empty.
# ---------------------------------------------------------
mysql_check_remote () {

    echo "${blue}Checking if the remote database was really emptied...$reset"

    get_remote_db_details

    db_exists=$(mysql "-u$r_db_user" "-p$r_db_pass" -h "$r_db_host" -BNse "SHOW DATABASES LIKE '$r_db_name'" | grep $r_db_name)

    if [[ ! "$db_exists" ]]
    then
        echo "${red}$msgError${reset} mysql could not connect to database $r_db_name. Check that your login details are set correctly and that the database exists. Exiting."
        exit 1;
    fi

    rows=$(mysql "-u$r_db_user" "-p$r_db_pass" -h "$r_db_host" --show-warnings -Bse "select count(distinct \`table_name\`) from \`information_schema\`.\`columns\` where \`table_schema\` = '$r_db_name'")

    if [ "$rows" == "0" ]; then
        echo "$green$msgSuccess$reset The database $r_db_name is empty, it has $rows rows."
    else
        echo "$red$msgError$reset Database $r_db_name is not empty, it still has $rows rows."
        exit 1
    fi
}


# ---------------------------------------------------------
# replace_remote_db ()
# Drop and recreate remote database.
# ---------------------------------------------------------
replace_remote_db () {

    get_remote_db_details

    msg='Dropping remote database...'
    echo "$blue$msg$reset" 

    echo

    if [[ ! "$no_drop" ]]
    then

        # do this if the standard `drop database` command is available
        mysql -u$r_db_user -p$r_db_pass -h $r_db_host --show-warnings -Bs<<EOF
        create database if not exists $r_db_name;
        drop database $r_db_name;
        create database $r_db_name;
EOF

    else
        # otherwise do this if `drop database` is not available
        sql_show="show databases; create database if not exists $r_db_name;"

        echo "mysql -u$r_db_user -p$r_db_pass -h $r_db_host --show-warnings -Bse $sql_show"

        mysql -u$r_db_user -p$r_db_pass -h $r_db_host --show-warnings -Bse "$sql_show"  

        echo "mysql --silent --skip-column-names -u $r_db_user -p$r_db_user $r_db_host -e "show tables" | gawk '{print "drop table " $1 ";"}' | mysql -u $r_db_user -p$r_db_user $r_db_host"

        mysql -u $r_db_user -p$r_db_user $r_db_host -sNe "show tables" | gawk '{print "drop table " $1 ";"}' | mysql -u $r_db_user -p$r_db_user $r_db_host

        sql_create="create database $r_db_name"
        mysql -u$r_db_user -p$r_db_pass -h $r_db_host --show-warnings -Bse "$sql_create"

    fi

    mysql_check_remote || exit 1

    echo
    echo "${blue}Replacing contents of remote database...$reset"
    echo
    cd $HOME/$r_web_dir/$r_bak_dir

    echo "bunzip2 < ${l_bak_name2}.bz2 | mysql -u$r_db_user -p$r_db_pass -h $r_db_host $r_db_name --show-warnings"

    set -o pipefail

    if bunzip2 < ${l_bak_name2}.bz2 | mysql -u$r_db_user -p$r_db_pass -h $r_db_host $r_db_name --show-warnings
    then
        echo
        echo "$green$msgSuccess$reset Replaced database contents."
    else
        echo
        echo "$red$msgError$reset Failed to replace contents of remote database."
    fi

    echo
}


# ---------------------------------------------------------
# install_search_scripts ()
# Check if wget or curl commands exit, then download the Search and Replace scripts.
# ---------------------------------------------------------
install_search_scripts () {

    pwd
    echo "${blue}Installing search and replace scripts...$reset"
    echo

    if [ ! -f "$searchScriptName" -o ! -f "$cliScriptName" ] 
    then 
        echo "${blue}Downloading $searchScriptName and $cliScriptName...$reset"
        echo

        if command -v wget >/dev/null 2>&1
        then
            echo "wget --no-check-certificate $searchScriptPath $cliScriptPath"
            wget --no-check-certificate $searchScriptPath $cliScriptPath
        else
            if command -v curl >/dev/null 2>&1
            then
                echo "curl -O $searchScriptPath -O $cliScriptPath"
                curl -O $searchScriptPath -O $cliScriptPath
            else
                echo >&2 "${red}$msgError$reset Installation of Search and Replace Tool requires wget or curl, which appear to be missing. Exiting."
                exit 1
            fi
        fi

        if [ -f "$searchScriptName" -a -f "$cliScriptName" ]
        then
            echo
            echo "${green}$msgSuccess$reset $searchScriptName and $cliScriptName downloaded to $r_site_dir/$r_bak_dir/"
            echo "chmod a+x $searchScriptName $cliScriptName"
            chmod a+x $searchScriptName $cliScriptName
        else
            echo
            echo
            echo >&2 "${red}$msgError$reset Search and Replace Tool download failed."
            exit 1
        fi
    fi
}


# ---------------------------------------------------------
# search_replace_remote ()
# Install the Search and Replace Tools locally then execute them.
# ---------------------------------------------------------
search_replace_local () {
    #
    # Search and replacing fields
    #
    cd $l_bak_dir

    install_search_scripts

    echo "$blue}Search and replace database fields.$reset"

    get_local_db_details

    # If $l_db_host is set to localhost, the CLI script will fail. The reason
    # is that "localhost" is a special name for the mysql driver making it use
    # the unix socket to connect to mysql instead of the tcp socket. A simple
    # solution is to swap localhost for 127.0.0.1.
    [[ "$l_db_host" == "localhost" ]] && l_db_host="127.0.0.1"

    cd $l_bak_dir

    echo "./$cliScriptName -h "$l_db_host" -u $l_db_user -n $l_db_name -p [password hidden for security] -c utf\-8 -s "$r_web_addr" -r "${l_web_addr:-$l_web_dir}" "

    ./$cliScriptName -h "$l_db_host" -u $l_db_user -n $l_db_name -p $l_db_pass -c utf\-8 -s "$r_web_addr" -r "${l_web_addr:-$l_web_dir}" 


}

# ---------------------------------------------------------
# do_search_replace_remote ()
# Login to remote server and execute search and replace function.
# ---------------------------------------------------------
do_search_replace_remote () {
    [[ "$checked" ]] || do_check_for_dirs

    ssh $ssh_port$r_user@$r_host "cd $r_web_dir; if [ ! -f .bashrc -a -f /etc/profile ]; then . /etc/profile; fi; ./$(basename $0) search_replace_remote;"
}

# ---------------------------------------------------------
# search_replace_remote ()
# Install the Search and Replace Tools on the remote server, execute them, then delete them.
# ---------------------------------------------------------
search_replace_remote () {

    get_remote_db_details

    cd $HOME/$r_web_dir/$r_bak_dir

    install_search_scripts

    echo
    echo "${blue}Search and replace database fields...$reset" 

    my_php=$(which php)
    default_php=/usr/bin/php

    # replace the shebang line with custom php binary
    if [[ "$my_php" != "$default_php" ]]
    then

        echo "${yellow}PHP Binary:$reset Your server uses $my_php"

        old_shebang=$(sed -n 1p "${cliScriptName}")
        sed -i "1c #!${my_php} -q" $cliScriptName

        echo "Shebang line changed from ${yellow}${old_shebang}$reset to $yellow#!${my_php} -q$reset"
        echo
    else
        echo "${yellow}PHP Binary:$reset Your server uses the default $default_php"
    fi

    echo

    echo "./$cliScriptName -h $r_db_host -u $r_db_user -n $r_db_name -p [password hidden for security] -c utf\-8 -s $l_web_addr -r $r_web_addr"

    ./$cliScriptName -h "$r_db_host" -u "$r_db_user" -n "$r_db_name" -p "$r_db_pass" -c utf\-8 -s "$l_web_addr" -r "$r_web_addr"

    if [[ $? != 0 ]]; then
        echo "$red$msgError$reset Failed to search and replace remote database."
    else
        echo "${green}$msgSuccess$reset Search and replace complete."
    fi

    # for security purposes, delete search scripts 
    rm "$cliScriptName" "$searchScriptName"

}

# ---------------------------------------------------------
# do_remote_operations ()
# Login to remote server and execute replace_remote_db() method.
# ---------------------------------------------------------
do_remote_operations () {

    [[ "$checked" ]] || do_check_for_dirs

    ssh $ssh_port$r_user@$r_host "cd $r_web_dir; if [ ! -f .bashrc -a -f /etc/profile ]; then . /etc/profile; fi; ./$(basename $0) replace_remote_db;"

}


# ---------------------------------------------------------
# rsync_push ()
# Synchronize the remote uploads folder with the contents of your local uploads
# folder.
# ---------------------------------------------------------
rsync_push () {
    echo "rsync -rave "ssh -l $r_user" $l_upload_path $r_host:$r_upload_path"
    rsync -rave "ssh $ssh_port-l $r_user" "$l_upload_path" "$r_host":"$r_upload_path"
} 

# ---------------------------------------------------------
# rsync_uploads ()
# Synchronize the local uploads folder with the contents of your remote uploads
# folder.
# ---------------------------------------------------------
rsync_pull () {
    echo "rsync -rave "ssh -l $r_user" "$r_host":"$r_upload_path" "$l_upload_path""
    rsync -rave "ssh $ssh_port-l $r_user" "$r_host":"$r_upload_path" "$l_upload_path"
} 

# ---------------------------------------------------------
# say_goodbye ()
# Print exit message.
# ---------------------------------------------------------
say_goodbye () {
    echo
    echo "${blue}Exiting. Thanks for using SyncDB.$reset"
    echo
}


# ====================================
#  ROUTINES
# ====================================

# ---------------------------------------------------------
# push ()
# Execute a sequence of commands to update your remote server with the contents
# of your local server.
# ---------------------------------------------------------
push () {

    test_ssh

    backup_local_db

    upload_local_db

    upload_script

    do_login_backup

    do_remote_operations

    do_search_replace_remote

    rsync_push

    say_goodbye

}


# ---------------------------------------------------------
# pull ()
# Execute a sequence of commands to update your local server with the contents
# of your remote server.
# ---------------------------------------------------------
pull () {

    test_ssh

    upload_script

    do_login_backup

    download_remote_db

    backup_local_db

    replace_local_db

    search_replace_local

    rsync_pull

    say_goodbye

}


# ====================================
#  ACTUAL SCRIPT EXECUTION
# ====================================

echo
echo "${blue}SyncDB v0.2.4$reset > $yellow${@:-push}$reset"
echo

# if an argument is passed (the number of arguments is not equal to zero), then check if that command is valid or not.
if [ $# -ne 0 ]
then
    # place all the command names in an array
    declare -a list_of_methods=(help upload_local_db get_local_db_details get_remote_db_details download_remote_db backup_local_db backup_remote_db replace_remote_db search_replace_remote push pull replace_local_db search_replace_local rsync_pull say_goodbye do_remote_operations do_search_replace_remote rsync_push do_login_backup upload_script test_ssh)

    # function to check if an item exists in an array
    contains_element () {
      local e
      for e in "${list_of_methods[@]}"
          do [[ "$e" == "${1:-push}" ]] && return 0
      done
      return 1
    }

    contains_element "$@"

    # if command is invalid, list the valid ones
    if [[ $? -eq 1 ]]
    then 
        echo ${red}Error:$reset Command not found: ${yellow}"$@"$reset
        echo

        help
    fi

fi

# script will execute whichever method is passed to it as an argument.
# The default is to run the `push` method.
${@:-push}


exit 
